{"title":"19+ JavaScript Shorthand Coding Techniques","sourceUrl":"https://www.sitepoint.com/shorthand-javascript-techniques/","path":"JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/","category":"JavaScript","tags":["JavaScript"," Tips & Tricks"],"excerpt":"This really is a must read for any JavaScript-based developer. I have written this article as a vital source of reference for learning shorthand JavaScript coding techniques that I have picked up over the years. To help you understand what is going on I have included the longhand versions to give some coding perspective.","date":{"$$date":1539619973105},"coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"2018-10-12\"\ntitle: \"19+ JavaScript Shorthand Coding Techniques\"\ntags: [\"JavaScript\",\"Tips & Tricks\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"This really is a must read for any JavaScript-based developer. I have written this article as a vital source of reference for learning shorthand JavaScript coding techniques that I have picked up over the years. To help you understand what is going on I have included the longhand versions to give some coding perspective.\"\ncoverImage: \"\"\nsourceUrl: \"https://www.sitepoint.com/shorthand-javascript-techniques/\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","_id":"2DKvxBjoYH9lL4Vq","htmlCode":{}}
{"title":"test 123 456 111 555","sourceUrl":"https://picturepan2.github.io/spectre/elements.html#forms","path":"JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/JavaScript/","category":"JavaScript","tags":["JavaScript"," ES6"],"excerpt":"Testing 123456","date":{"$$date":1539872932689},"coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"\"\ntitle: \"test 123\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","_id":"HAn31eSLj4IY86mL","htmlCode":"<div id=\"wrapper-container\"><div><div><div><div><div><div><div><div><div><p>TEhis is test</p>\n<pre class=\"css\" style=\"font-weight: 12px;\"><code>\n&lt;html&gt;\n&lt;body class=\"test\"&gt;&lt;/body&gt;\n&lt;/html&gt;\n</code>\n</pre></div></div></div></div></div></div></div></div></div></div>"}
{"title":"Building forms using React — everything you need to know","sourceUrl":"https://www.codementor.io/blizzerand/building-forms-using-react-everything-you-need-to-know-iz3eyoq4y","path":"React/React/React/React/Building forms using React — everything you need to know","category":"React","tags":["React"," Form"],"excerpt":"test","date":{"$$date":1539094456041},"coverImage":"https://reactjs.org/docs/forms.html","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"\"\ntitle: \"rererer\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","markdownCode":"Forms are integral to any modern application. They serve as a basic medium for users to interact with your app. Developers rely on forms for everything: securely logging in the user, searching and filtering the product list, booking a product, and building a cart, etc. More complex applications built for enterprises are usually more form-intensive, with the input fields spanning over multiple tabs. On top of that, you have to consider the validation logic that needs to be deployed.\n\nIn this tutorial, we're going to look at how React handles forms. We'll cover not just the basics, but also form validation and best practices too — even experienced developers get certain details wrong.\n\nLet's get started.\n\n[](#creating-a-form-controlled-component-vs-uncontrolled-component)Creating a Form — Controlled Component vs. Uncontrolled Component\n------------------------------------------------------------------------------------------------------------------------------------\n\nReact offers a stateful, reactive approach to building forms. Unlike other DOM elements, HTML form elements work differently in React. The form data, for instance, is usually handled by the component rather than the DOM, and is usually implemented using controlled components. The image below perfectly describes how controlled components work in React.\n\n![react.png](https://process.filestackapi.com/cache=expiry:max/Qb7pi8kTzenybAUcijaB)\n\nThe form’s structure is similar to those of the usual HTML forms. However, each input element gets a component of its own, which we call dumb components. The container component is responsible for maintaining the state. The difference is, we're using a callback function to handle form events and then using the container’s state to store the form data. This gives your component better control over the form control elements and the form data.\n\nThe callback function is triggered on events, including change of form control values, or on form submission. The function then pushes the form values into the local state of the component and the data is then said to be controlled by the component. Because we are using the value attribute on the form element, the value displayed will be the value of `this.state.value`.\n\nThere is another technique, popularly known as uncontrolled components, for creating input forms. This is more like traditional HTML forms because the input form data is stored inside the DOM and not within the component. Elements like `<input>`and `<textarea>` maintain their own state, which they update when the input values change. You can query the DOM for the value of an input field using a ref.\n\nHere is an example from the [official docs](https://reactjs.org/docs/uncontrolled-components.html) that demonstrate how uncontrolled components work.\n\n```javascript\n class NameForm extends Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(e) {\n    alert('The value is: ' + this.input.value);\n    e.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n\n\n```\n\nHere, the `<input>` component is responsible for storing its state. The ref attribute creates a reference to the DOM node accessible and you can pull this value when you need it — when you're about to submit the form in the example.\n\nReact recommends using controlled components over refs to implement forms. Refs offer a backdoor to the DOM, which might tempt you to use it to do things the jQuery way. Controlled components, on the other hand, are more straightforward — the form data is handled by a React component. However, if you want to integrate React with a non-React project, or create a quick and easy form for some reason, you can use a `ref`. The rest of this tutorial is going to focus on controlled components.\n\n[](#react-form-demo)React Form Demo\n-----------------------------------\n\nHere is the codesandobx demo for the form that we’ll be creating today.  \n@[React Form Demo](http://codesandbox.io/embed/x8omy0p9z)\n\nYou can also grab a copy of the code from [my GitHub repo](https://github.com/blizzerand/react-forms). Clone the repo, run `npm install`, and then run `npm start`.\n\n[](#structuring-a-form)Structuring a Form\n-----------------------------------------\n\nReact's composition model lets you organize your code into smaller reusable components. Each component exists as an independent functional unit and an hierarchy of components can be used to represent a specific feature. This structure works particularly well with forms. You can create custom components for `<input>`, `<textarea>`, `<select>`, etc. and reuse them to compose a `FormContainer` component.\n\nNote: although it could be tempting to use a form library instead, chances are high that you might come across obstacles when you need to add custom behavior and validation. Creating a reusable form component from scratch will help you bolster your understanding of React forms.\n\n```javascript\nimport React, { Component } from 'react';  \nimport './styles.css';  \nimport FormContainer from './containers/FormContainer';\n\nclass App extends Component {  \n  render() {\n    return (\n      <div className=\"container\">\n        <h3>React Form</h3>\n        <FormContainer />\n      </div>\n    );\n  }\n}\n\nexport default App; \n\n```\n\nFormContainer is a container component that renders all of the form elements and handles all of the business logic. We call it a container component because it takes care of updating the state of the form, handling form submission, and making API calls/dispatching Redux actions. The dumb components or presentational components are concerned with how things look and contain the actual DOM markup. These components receive data and callbacks exclusively as props. I've covered more about it on my [Stateful vs. Stateless components in React](https://code.tutsplus.com/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541) tutorial.\n\nLet's move on and create a container:\n\n```javascript\nimport React, {Component} from 'react';  \n\n/* Import Components */\nimport CheckBox from '../components/CheckBox';  \nimport Input from '../components/Input';  \nimport TextArea from '../components/TextArea';  \nimport Select from '../components/Select';\nimport Button from '../components/Button'\n\nclass FormContainer extends Component {  \n  constructor(props) {\n    super(props);\n\n    this.state = {\n      newUser: {\n        name: '',\n        email: '',\n        age: '',\n        gender: '',\n        expertise: '',\n        about: ''\n\n      },\n\n      genderOptions: ['Male', 'Female', 'Others'],\n      skillOptions: ['Programming', 'Development', 'Design', 'Testing']\n\n    }\n    this.handleFormSubmit = this.handleFormSubmit.bind(this);\n    this.handleClearForm = this.handleClearForm.bind(this);\n  }\n\n  /* This life cycle hook gets executed when the component mounts */\n\n  handleFormSubmit() {\n    // Form submission logic\n  }\n  handleClearForm() {\n    // Logic for resetting the form\n  }\n  render() {\n    return (\n      <form className=\"container\" onSubmit={this.handleFormSubmit}>\n\n        <Input /> {/* Name of the user */}\n        <Input /> {/* Input for Age */} \n        <Select /> {/* Gender Selection */}\n        <CheckBox /> {/* List of Skills (eg. Programmer, developer) */}\n        <TextArea /> {/* About you */}\n        <Button /> { /*Submit */ }\n        <Button /> {/* Clear the form */}\n      </form>\n    );\n  }\n}\n\nexport default FormContainer;\n}\n\n```\n\nFirst, we've imported the dumb components from the components directory. The components include `<Input>`, `<Select>`, `<CheckBox>`, `<TextArea>`, and `<Button>`.\n\nThen, we have initiated the state for storing the user data and the UI data. Two methods — `handleFormSubmit()` and `handleClearForm()` — have been created to handle the form logic. The render method renders all of the input fields and buttons required for our sign up form.\n\n[](#composing-the-dumb-components)Composing the Dumb Components\n---------------------------------------------------------------\n\nWe've laid out the structure of the form. Next, we need to compose the child components. Let's go through the components one by one.\n\n[](#input)<Input />\n-------------------\n\nThe `<Input />` component displays a one-line input field. The input type could be either text or number. Let's have a look at the props that we need to create an `<Input />` component.\n\n*   `type` — The `type` prop determines whether the input field rendered is of type, text, or number. For instance, if the value of `type` is equal to number, then `<input type=\"number\" />` will be rendered. Otherwise, `<input type=\"text\" />` gets rendered.\n*   `title` — The value of the title prop will be displayed as a label of that particular field.\n*   `name` — This is the name attribute for the input.\n*   `value` — The value (either text or number) that should be displayed inside the input field. You can use this prop to give default value.\n*   `placeholder` — An optional string that you can pass so that the input field displays a placeholder text.\n*   `handleChange` — A control function that gets triggered when the input control element's value changes. The function then updates the state of the parent component and passes the new value through the value prop.\n\nHere's the code for the `<Input/>` component. Note that we're using stateless functional components here.\n\n```javascript\nconst Input = (props) => {\n    return (  \n  <div className=\"form-group\">\n    <label htmlFor={props.name} className=\"form-label\">{props.title}</label>\n    <input\n      className=\"form-input\"\n      id={props.name}\n      name={props.name}\n      type={props.type}\n      value={props.value}\n      onChange={props.handleChange}\n      placeholder={props.placeholder} \n    />\n  </div>\n)\n}\n\nexport default Input;\n\n```\n\nYou can further expand the list of possible attributes and add them as props. Here is what the component's declaration looks like:\n\n```javascript\n<Input type={'text'}\n               title= {'Full Name'} \n               name= {'name'}\n               value={this.state.newUser.name} \n               placeholder = {'Enter your name'}\n               handleChange = {this.handleFullName}\n               /> {/* Name of the user */}\n               \n\n```\n\nThe `handleChange` callback takes care of updating the state and the updated value propagates through `props.value`. I am going to name the callback function as `handleFullName`.\n\n```javascript\n/* FormContainer.jsx */\n\n//...\n  handleFullName(e) {\n   let value = e.target.value;\n   this.setState( prevState => ({ newUser : \n        {...prevState.newUser, name: value\n        }\n      }))\n  }\n//...\n\n```\n\nThe `setState` accepts either an object or an updater function with the following signature.\n\n```\n(prevState, props) => stateChange\n\n```\n\nThe `prevState` object holds the up-to-date value of the previous state. We are going to merge the updated values with the previous state.\n\n_Note_: in JavaScript, class methods are not bound by default. You will need to bind it manually. What does that mean? You will need to add a binding into the constructor for each class method and the binding will look like this:\n\n```\nthis.handleFullName = this.handleFullName.bind(this)\n\n```\n\nAlternatively, you can use [class fields](https://github.com/tc39/proposal-class-fields) to do binding outside the constructor. The feature is still in experimental phase, so you will need to install the babel plugin [transform-class-properties to support it](https://babeljs.io/docs/plugins/transform-class-properties/).\n\nThe next input field is going to be for age. The logic of the `handleAge` will be similar to that of the `handleFullName` method.\n\n```\n/* FormContainer.jsx */\n\nhandleAge(e) {\n       let value = e.target.value;\n   this.setState( prevState => ({ newUser : \n        {...prevState.newUser, age: value\n        }\n      }), () => console.log(this.state.newUser))\n  }\n\n```\n\nThis method updates the state of this.state.newUser.age. Although this approach is okay, you can refactor the code and create a generic handler method that works for all `<Input />` components.\n\n```\n/* FormContainer.jsx */\n\nhandleInput(e) {\n     let value = e.target.value;\n     let name = e.target.name;\n     this.setState( prevState => {\n        return { \n           newUser : {\n                    ...prevState.newUser, [name]: value\n                   }\n        }\n     }, () => console.log(this.state.newUser)\n     )\n }\n\n```\n\n`handleInput()` will replace both `handleFullName()` and `handleAge()`. The only change we've made is to extract the value of name from form variable and then use that data to set the state. So, the value of the name prop should be same as the key of the property in the state.\n\nNext up, `<Select />`.\n\n[](#select)<Select />\n---------------------\n\nThe `<Select />` component displays a list of drop-down items. Usually, there will be a placeholder text or a default value for the drop-down. Here are the props for the `<Select />`:\n\n*   `title` — The value of the title prop be displayed as label of the `<select>` element.\n*   `name` — The name attribute for the `<select>` element.\n*   `options` — An array of available options. For instance, we are using the `<select />` to display a drop-down list of gender options.\n*   `value` — The value prop can be used to set the default value of the field.\n*   `placeholder` — A short string that populates the first `<option>` tag.\n*   `handleChange` — A control function that gets triggered when the input control element's value changes. The function then updates the state of the parent component and passes the new value through the value prop.\n\nLet's have a look at the actual code for the `<Select />` component.\n\n```javascript\n/*Select.jsx*/\n\nconst Select = (props) => {\n    return(\n        <div className=\"form-group\">\n            <label htmlFor={props.name}> {props.title} </label>\n            <select\n              name={props.name}\n              value={props.value}\n              onChange={props.handleChange}\n              >\n              <option value=\"\" disabled>{props.placeholder}</option>\n              {props.options.map(option => {\n                return (\n                  <option\n                    key={option}\n                    value={option}\n                    label={option}>{option}\n                  </option>\n                );\n              })}\n            </select>\n      </div>)\n}\n\nexport default Select;\n\n```\n\nThe first option tag is populated with the placeholder string. The rest of the options are mapped from the array that we passed on as props. While using the map method to iterate through DOM elements, remember to add a `key` attribute that's unique. This helps React keep track of DOM updates. If you leave out the `key` attribute, you will see a warning in your browser and might encounter performance issues down the road.\n\nNow, let's have a look at the callback function. The logic for method is similar to that of the generic handleInput that we created earlier. We can actually plug in that handler method as a prop and everything should work as expected.\n\n```javascript\n<Select title={'Gender'}\n       name={'gender'}\n       options = {this.state.genderOptions} \n       value = {this.state.newUser.gender}\n       placeholder = {'Select Gender'}\n       handleChange = {this.handleInput}\n/> {/* Age Selection */}\n\n```\n\n[](#checkbox)<CheckBox/>\n------------------------\n\nCheckboxes might appear a bit more complicated because arrays are involved. But both `<CheckBox>` and `<Select>` are similar in terms of props. The major difference lies in how the state is updated. Let's have a look at the props first.\n\n*   `title` — Already covered.\n*   `name` — Already covered.\n*   `options` — An array of available options. The array is usually composed of strings that end up being the label and the value of each checkbox.\n*   `selectedOptions` — An array of selected values. If the user had selected certain choices beforehand, the selectedOptions array would be populated with those values. This is synonymous to the <Select /> component's value prop.\n*   `handleChange` — Already covered.\n\nHere's the CheckBox component.\n\n```javascript\n/* CheckBox.jsx */\n\nconst CheckBox = (props) => {\n\n    return( <div>\n    <label for={props.name} className=\"form-label\">{props.title}</label>\n    <div className=\"checkbox-group\">\n      {props.options.map(option => {\n        return (\n          <label key={option}>\n            <input\n              className=\"form-checkbox\"\n              id = {props.name}\n              name={props.name}\n              onChange={props.handleChange}\n              value={option}\n              checked={ props.selectedOptions.indexOf(option) > -1 }\n              type=\"checkbox\" /> {option}\n          </label>\n        );\n      })}\n    </div>\n  </div>\n);\n\n}\n\n```\n\nThe line `checked={ props.selectedOptions.indexOf(option) > -1 }` might be confusing if you've never used JavaScript's `indexOf` method before. `indexOf` checks whether a particular item exists within an array and returns its index. Assuming that option holds a string, it checks whether the string exists within the `selectedOptions` and if the item doesn't exist in the array, it will return -1. This is the easiest way to populate values to a checkbox group in a form.\n\nSince we need to push an array into the state, which is more complicated than the usual `handleInput()`, let's create a new method for handling checkboxes.\n\n```javascript\nhandleSkillsCheckBox(e) {\n\n    const newSelection = e.target.value;\n    let newSelectionArray;\n\n    if(this.state.newUser.skills.indexOf(newSelection) > -1) {\n      newSelectionArray = this.state.newUser.skills.filter(s => s !== newSelection)\n    } else {\n      newSelectionArray = [...this.state.newUser.skills, newSelection];\n    }\n\n      this.setState( prevState => ({ newUser:\n        {...prevState.newUser, skills: newSelectionArray }\n      })\n      )\n}\n\n```\n\nThe user can interact with the checkbox in two ways — check an item, or uncheck an existing item. This user interaction corresponds to two actions — adding an item into the array, or removing an existing item from the array.\n\nThe `newSelection` variable has the value of the newly selected (or deselected) item. We compare it with the existing selection of items stored at `this.state.newUser.skills`. We're again going to rely on `indexOf` to check whether the string stored in `newSelection` is already of the array.  \nIf it's part of the array, the condition falls true and the new selection item is filtered out and stored in newSelection. Otherwise, the newSelection item is concatenated into the array using spread operator.\n\nFinally, the state is updated using `this.setState`.\n\n[](#textarea)<TextArea />\n-------------------------\n\nI am going to leave this as an exercise for the reader. This is fairly similar to the `<Input />` component that we created earlier. The `<textarea />` element should accept additional props for rows and columns. The code for the `TextArea` component is available in the sandbox demo for reference.\n\n[](#button)<Button />\n---------------------\n\nButtons are easiest of the lot. You can keep the `<Button />` component fairly simple and easy. Here is are the list of props that a button requires:\n\n*   `title` — Text for the button.\n*   `action` — Callback function\n*   `style` — Style objects can be passed as props.\n\nHere's the `<Button/>` in action:\n\n```javascript\n/*Button.jsx */\nconst Button = (props) => {\n    console.log(props.style);\n    return(\n        <button \n            style= {props.style} \n            onClick= {props.action}>    \n            {props.title} \n        </button>)\n}\n\nexport default Button;\n\n```\n\n[](#form-actions-handleclearform-and-handleformsubmit)Form Actions — `handleClearForm` and `handleFormSubmit`\n-------------------------------------------------------------------------------------------------------------\n\nWe've nearly reached the end of the tunnel. The last step is to compose the form actions. Since the FormContainer component maintains the state, the form action methods will go there.\n\nThe `handleClearForm` method will clear the state and set it back to its initial values.\n\n```javascript\nhandleClearForm(e) {\n\n      e.preventDefault();\n      this.setState({ \n        newUser: {\n          name: '',\n          age: '',\n          gender: '',\n          skills: [],\n          about: ''\n        },\n      })\n  }\n\n```\n\nThe line `e.preventDefault()` prevents the page from being refreshed on form submission, which is the default form behavior.\n\nThe `handleFormSubmit()` method takes care of making AJAX requests to the server. The data that needs to be sent is available at this.state.newUser. There are many libraries that you can use to make AJAX calls. I am going to use fetch here.\n\n```javascript\nhandleFormSubmit(e) {\n    e.preventDefault();\n    let userData = this.state.newUser;\n\n    fetch('http://example.com',{\n        method: \"POST\",\n        body: JSON.stringify(userData),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n      }).then(response => {\n        response.json().then(data =>{\n          console.log(\"Successful\" + data);\n        })\n    })\n  }   \n\n```\n\nThat's it!\n\n[](#summary)Summary\n-------------------\n\nIn this article, we've covered everything that you need to know about building forms in React. React has component-based architecture and the components are meant to be reusable. We've gone ahead and created components for the input elements, such as: `<input/>`, `<select />`, `<textArea/>`, etc. You can further customize the components according to your requirements by passing more props.\n\nI hope you've had a good read. What are your thoughts about building forms using React? If you have anything to share, let us know in the comments.","_id":"RnFGXODGFlwDUYjI"}
{"title":"Understanding React Higher-Order Components by Example","sourceUrl":"https://levelup.gitconnected.com/understanding-react-higher-order-components-by-example-95e8c47c8006","path":"React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/React/","category":"React","tags":["React"," HOC"],"excerpt":"Build a React higher-order component step-by-step to understand how to implement the HOC pattern","date":{"$$date":1539621355364},"coverImage":"","type":"Post","frontmatter":"---\npath: \"React/\"\ndate: \"2018-10-15\"\ntitle: \"Understanding React Higher-Order Components by Example\"\ntags: [\"React\",\"HOC\"]\ncategory: \"React\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"Build a React higher-order component step-by-step to understand how to implement the HOC pattern\"\ncoverImage: \"\"\nsourceUrl: \"https://levelup.gitconnected.com/understanding-react-higher-order-components-by-example-95e8c47c8006\"\ntype: \"Post\"\n---\n    ","filePath":"pages/React/.md","_id":"ViCaT7Hot8Og0292","htmlCode":"<div><div><h1>Understanding React Higher-Order Components by&nbsp;Example</h1><h2>Build a React higher-order component step-by-step to understand how to implement the HOC&nbsp;pattern</h2><p>In this tutorial we will cover the concepts needed to build your own higher-order components (HOC). We will implement a HOC to save React state to <code>localStorage</code>, called <code>withStorage</code>, that will allow you to inject the functionality into components without needing to duplicate the logic across your entire application.</p><blockquote>If you’re interested in see the same example in render props, check out <a data->this article</a></blockquote></div><div><h3>An introduction to&nbsp;HOC</h3><p>A higher-order component in React is a pattern used to share common functionality between components without repeating code. A higher-order component is actually not a component though, <span data-creator->it is a function</span>. A HOC function takes a component as an argument and returns a component. It transforms a component into another component and adds additional data or functionality. In short:</p><pre>const NewComponent = (BaseComponent) =&gt; {<br>  // ... create new component from old one and update<br>  return UpdatedComponent<br>}</pre><p>Two HOC’s implementations that you may be familiar with in the React ecosystem are <code>connect</code> from Redux and <code>withRouter</code> from React Router. The <code>connect</code> function from Redux is used to give components access to the global state in the Redux store, and it passes these values to the component as props. The <code>withRouter</code> function injects the router information and functionality into the component, enabling the developer access or change the route.</p></div><div><h3>The higher-order component pattern</h3><p>A higher-order component is a function that takes a component as an argument and returns a component. This means that a HOC will always have a form similar to the follow:</p><pre><code>import React from 'react';<br><br>const higherOrderComponent = (WrappedComponent) =&gt; {<br>  class HOC extends React.Component {<br>    render() {<br>      return &lt;WrappedComponent /&gt;;<br>    }<br>  }<br>    <br>  return HOC;<br>};</code></pre><p>The <code>higherOrderComponent</code> is a function that takes a component called <code>WrappedComponent</code> as an argument. We create a new component called <code>HOC</code> which returns the <code>&lt;WrappedComponent/&gt;</code> from its <code>render</code> function. While this actually adds no functionality in the trivial example, it depicts the common pattern that every HOC function will follow. We can invoke the HOC as follows:</p><pre>const SimpleHOC = <code>higherOrderComponent</code>(MyComponent);</pre><h3>A basic HOC by&nbsp;example</h3><p>Now we will extend our basic higher-order component pattern to inject data into our wrapped.</p><p>Our team has actually figured out the <code>secretToLife</code> which turns out to be the number <code>42</code>. Some of our components need to share this information, and we can create a HOC called <code>withSecretToLife</code> to pass it as a prop to our components.</p><pre><code>import React from 'react';<br><br>const withSecretToLife = (WrappedComponent) =&gt; {<br>  class HOC extends React.Component {<br>    render() {<br>      return (<br>        &lt;WrappedComponent<br>          {...this.props}<br>          secretToLife={42}<br>        /&gt;<br>      );<br>    }<br>  }<br>    <br>  return HOC;<br>};<br><br>export default withSecretToLife;</code></pre><p>Notice that this HOC is almost identical to our basic pattern. All we have done is add a prop <code>secretToLife={42}</code>, which allows the wrapped component to access the value by calling <code>this.props.secretToLife</code>.</p><p>The other addition is that we spread the props passed to the component. This ensures that any other props that are passed to the wrapped component will be accessible via <code>this.props</code> in the same manner they would be called if the component was not passed through our higher-order component function.</p><pre><code>import React from 'react';<br>import withSecretToLife from 'components/withSecretToLife';<br><br>const DisplayTheSecret = props =&gt; (<br>  &lt;div&gt;<br>    The secret to life is {props.secretToLife}.<br>  &lt;/div&gt;<br>);<br><br>const WrappedComponent = withSecretToLife(DisplayTheSecret);<br><br>export default WrappedComponent;</code></pre><p>Our <code>WrappedComponent</code>, which is just an enhanced version of <code>&lt;DisplayTheSecret/&gt;</code>, will allow us to access <code>secretToLife</code> as a prop.</p><h3>A practical HOC by&nbsp;example</h3><p>Now that we have a solid grasp on the fundamental pattern for HOC, we can build one that is practical for a real application. A higher-order component has access to all the default React API, including <code>state</code> and the lifecycle methods.</p><p>The functionality of our <code>withStorage</code> HOC will be to save/load the state of a component, allowing us to quickly access and render it on a page load.</p><pre><code>import React from 'react';<br><br>const withStorage = (WrappedComponent) =&gt; {<br>  class HOC extends React.Component {<br>    state = {<br>      localStorageAvailable: false, <br>    };<br>  <br>    componentDidMount() {<br>       this.checkLocalStorageExists();<br>    }<br>  <br>    checkLocalStorageExists() {<br>      const testKey = 'test';<br><br>      try {<br>          localStorage.setItem(testKey, testKey);<br>          localStorage.removeItem(testKey);<br>          this.setState({ localStorageAvailable: true });<br>      } catch(e) {<br>          this.setState({ localStorageAvailable: false });<br>      } <br>    }<br>  <br>    load = (key) =&gt; {<br>      if (this.state.localStorageAvailable) {<br>        return localStorage.getItem(key); <br>      }<br>      <br>      return null;<br>    }<br>    <br>    save = (key, data) =&gt; {<br>      if (this.state.localStorageAvailable) {<br>        localStorage.setItem(key, data);<br>      }<br>    }<br>    <br>    remove = (key) =&gt; {<br>      if (this.state.localStorageAvailable) {<br>        localStorage.removeItem(key);<br>      }<br>    }<br>    <br>    render() {<br>      return (<br>        &lt;WrappedComponent<br>          load={this.load}<br>          save={this.save}<br>          remove={this.remove}<br>          {...this.props}<br>        /&gt;<br>      );<br>    }<br>  }<br>    <br>  return HOC; <br>}<br><br>export default withStorage;</code></pre><p>At the top of <code>withStorage</code> we have a single item in the component’s state which tracks if <code>localStorage</code> is available in the given browser. We use the <code>componentDidMount</code> lifecycle hook which will check if localStorage exists in the <code>checkLocalStorageExists</code> function. Here it will test saving an item and set the state to true if it succeeds.</p><p>We also add three functions to our HOC — <code>load</code>, <code>save</code>, and <code>remove</code>. These are used to directly access the <code>localStorage</code> API if it is available. Our three functions on the HOC are passed to our wrapped component to be consumed there.</p><p>Now we will create a new component to be wrapped in our <code>withStorage</code> HOC. It will be used to display a user’s username and favorite movie. However, the API call to get this information takes a very long time. We can also assume that these values will never change once set.</p><p>To ensure we have a great user experience, we will make this API call only if the values haven’t been saved. Then every time the user returns to the page, they can access the data immediately instead of waiting for our API to return.</p><pre><code>import React from 'react';<br>import withStorage from 'components/withStorage';<br><br>class ComponentNeedingStorage extends React.Component {<br>  state = {<br>    username: '',<br>    favoriteMovie: '',<br>  }<br><br>  componentDidMount() {<br>    const username = this.props.load('username');<br>    const favoriteMovie = this.props.load('favoriteMovie');<br>    <br>    if (!username || !favoriteMovie) {<br>      // This will come from the parent component<br>      // and would be passed when we spread props {...this.props}<br>      this.props.reallyLongApiCall()<br>        .then((user) =&gt; {<br>          this.props.save('username', user.username) || '';<br>          this.props.save('favoriteMovie', user.favoriteMovie) || '';<br>          this.setState({<br>            username: user.username,<br>            favoriteMovie: user.favoriteMovie,<br>          });<br>        }); <br>    } else {<br>      this.setState({ username, favoriteMovie })<br>    }<br>  }<br><br>  render() {<br>    const { username, favoriteMovie } = this.state;<br>    <br>    if (!username || !favoriteMovie) {<br>      return &lt;div&gt;Loading...&lt;/div&gt;; <br>    }<br>    <br>    return (<br>      &lt;div&gt;<br>        My username is {username}, and I love to watch {favoriteMovie}.<br>      &lt;/div&gt;<br>    )<br>  }<br>}<br><br>const WrappedComponent = withStorage(ComponentNeedingStorage);<br><br>export default WrappedComponent;</code></pre><p>Inside the <code>componentDidMount</code> of our wrapped component, we first try to access the <code>username</code> and <code>favoriteMovie</code> from <code>localStorage</code>. If the values do not exist, we make our expensive API call named <code>this.props.reallyLongApiCall</code>. Once this function returns, we save the username and favorite to <code>localStorage</code> and update the component’s state to display them on the screen.</p><h3>Higher-order component considerations</h3><ul><li>A HOC should be a pure function with no side-effects. It should not make any modifications and just compose the original component by wrapping it in another component.</li><li>Do not use HOC’s in the render method of a component. Access the HOC outside the component definition.</li><li>Static methods must be copied over to still have access to them. A simple way to do this is the <code>hoist-non-react-statics</code> package.</li><li>Refs are not passed through.</li></ul></div></div>"}
{"title":"rererer ssasa","sourceUrl":"","path":"JavaScript/JavaScript/","category":"JavaScript","tags":["JavaScript"," ES6"],"excerpt":"","date":"","coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/JavaScript/\"\ndate: \"\"\ntitle: \"rererer ssasa\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/JavaScript/.md","markdownCode":"\\--- path: \"JavaScript/\" date: \"\" title: \"rererer\" tags: \\[\"JavaScript\",\"ES6\"\\] category: \"JavaScript\" categoryColor: \"#F3C610\" excerpt: \"\" coverImage: \"\" sourceUrl: \"\" type: \"Post\" ---","_id":"lfc0XqCms5pgYRBg"}
{"$$indexCreated":{"fieldName":"name","unique":false,"sparse":false}}
