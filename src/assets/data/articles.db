{"title":"19+ JavaScript Shorthand Coding Techniques","sourceUrl":"https://www.sitepoint.com/shorthand-javascript-techniques/","path":"JavaScript/","category":"JavaScript","tags":["JavaScript"," Tips & Tricks"],"excerpt":"This really is a must read for any JavaScript-based developer. I have written this article as a vital source of reference for learning shorthand JavaScript coding techniques that I have picked up over the years. To help you understand what is going on I have included the longhand versions to give some coding perspective.","date":"2018-10-12","coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"2018-10-12\"\ntitle: \"19+ JavaScript Shorthand Coding Techniques\"\ntags: [\"JavaScript\",\"Tips & Tricks\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"This really is a must read for any JavaScript-based developer. I have written this article as a vital source of reference for learning shorthand JavaScript coding techniques that I have picked up over the years. To help you understand what is going on I have included the longhand versions to give some coding perspective.\"\ncoverImage: \"\"\nsourceUrl: \"https://www.sitepoint.com/shorthand-javascript-techniques/\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","markdownCode":"![improve-your-javascript](https://dab1nmslvvntp.cloudfront.net/wp-content/uploads/jquery4u/2013/02/improve-your-javascript.jpg)\n\n**This really is a must read for any JavaScript-based developer**. I have written this article as a vital source of reference for learning shorthand JavaScript coding techniques that I have picked up over the years. To help you understand what is going on I have included the longhand versions to give some coding perspective.\n\n> **June 14th, 2017**: This article was updated to add new shorthand tips based on ES6. If you want to learn more about the changes in ES6, sign up for SitePoint Premium and check out our screencast [A Look into ES6](https://www.sitepoint.com/premium/screencasts/a-look-into-es2016)\n\n1\\. The Ternary Operator\n------------------------\n\n\\--ADVERTISEMENT--\n\nvar el = document.getElementById('aniBox'); var adBox = document.getElementById('adBox'); // create an observer instance var observer = new MutationObserver(function(mutations) { mutations.forEach(function(mutation) { if(mutation.attributeName == 'style'){ var s = el.getAttribute('style'); if(s.search('height: 360px') != -1) { adBox.style = 'display: block'; } else { adBox.style = 'display: none'; } } }); }); // configuration of the observer: var config = { attributes: true, attributeFilter: \\['style'\\]}; // pass in the target node, as well as the observer options observer.observe(el, config);\n\nThis is a great code saver when you want to write an if..else statement in just one line.\n\nLonghand:\n\n```jsx\nconst x = 20;\nlet answer;\nif (x > 10) {\n    answer = 'greater than 10';\n} else {\n    answer = 'less than 10';\n}\n\n```\n\nShorthand:\n\n```jsx\nconst answer = x > 10 ? 'greater than 10' : 'less than 10';\n\n```\n\nYou can also nest your if statement like this:\n\n```jsx\nconst answer = x > 10 ? \" greater than 10\" : x \n```\n\n2\\. Short-circuit Evaluation Shorthand\n--------------------------------------\n\nWhen assigning a variable value to another variable, you may want to ensure that the source variable is not null, undefined or empty. You can either write a long if statement with multiple conditionals, or use a short-circuit evaluation.\n\nLonghand:\n\n```jsx\nif (variable1 !== null || variable1 !== undefined || variable1 !== '') {\n     let variable2 = variable1;\n}\n\n```\n\nShorthand:\n\n```jsx\nconst variable2 = variable1  || 'new';\n\n```\n\nDon’t believe me? Test it yourself (paste the following code in [es6console](https://es6console.com/)):\n\n```jsx\nlet variable1;\nlet variable2 = variable1  || '';\nconsole.log(variable2 === ''); // prints true\n\nvariable1 = 'foo';\nvariable2 = variable1  || '';\nconsole.log(variable2); // prints foo\n\n```\n\n3\\. Declaring Variables Shorthand\n---------------------------------\n\nIt is good practice to declare your variable assignments at the beginning of your functions. This shorthand method can save you lots of time and space when declaring multiple variables at the same time.\n\nLonghand:\n\n```jsx\nlet x;\nlet y;\nlet z = 3;\n\n```\n\nShorthand:\n\n```jsx\nlet x, y, z=3;\n\n```\n\n4\\. If Presence Shorthand\n-------------------------\n\nThis might be trivial, but worth a mention. When doing “if checks”, assignment operators can sometimes be omitted.\n\nLonghand:\n\n```jsx\nif (likeJavaScript === true)\n\n```\n\nShorthand:\n\n```jsx\nif (likeJavaScript)\n\n```\n\n> **Note:** these two examples are not exactly equal, as the shorthand check will pass as long as `likeJavaScript` is a [truthy value](https://developer.mozilla.org/en-US/docs/Glossary/Truthy).\n\nHere is another example. If “a” is NOT equal to true, then do something.\n\nLonghand:\n\n```jsx\nlet a;\nif ( a !== true ) {\n// do something...\n}\n\n```\n\nShorthand:\n\n```jsx\nlet a;\nif ( !a ) {\n// do something...\n}\n\n```\n\n5\\. JavaScript for Loop Shorthand\n---------------------------------\n\nThis little tip is really useful if you want plain JavaScript and not rely on external libraries such as jQuery or lodash.\n\nLonghand:\n\n```jsx\nfor (let i = 0; i < allImgs.length; i++)\n\n```\n\nShorthand:\n\n```jsx\nfor (let index of allImgs)\n\n```\n\nShorthand for Array.forEach:\n\n```jsx\nfunction logArrayElements(element, index, array) {\n  console.log(\"a[\" + index + \"] = \" + element);\n}\n[2, 5, 9].forEach(logArrayElements);\n// logs:\n// a[0] = 2\n// a[1] = 5\n// a[2] = 9\n\n```\n\n6\\. Short-circuit Evaluation\n----------------------------\n\nInstead of writing six lines of code to assign a default value if the intended parameter is null or undefined, we can simply use a short-circuit logical operator and accomplish the same thing with just one line of code.\n\nLonghand:\n\n```jsx\nlet dbHost;\nif (process.env.DB_HOST) {\n  dbHost = process.env.DB_HOST;\n} else {\n  dbHost = 'localhost';\n}\n\n```\n\nShorthand:\n\n```jsx\nconst dbHost = process.env.DB_HOST || 'localhost';\n\n```\n\n7\\. Decimal base exponents\n--------------------------\n\nYou may have seen this one around. It’s essentially a fancy way to write numbers without the trailing zeros. For example, 1e7 essentially means 1 followed by 7 zeros. It represents a decimal base (which JavaScript interprets as a float type) equal to 10,000,000.\n\nLonghand:\n\n```jsx\nfor (let i = 0; i < 10000; i++) {}\n\n```\n\nShorthand:\n\n```jsx\nfor (let i = 0; i < 1e7; i++) {}\n\n// All the below will evaluate to true\n1e0 === 1;\n1e1 === 10;\n1e2 === 100;\n1e3 === 1000;\n1e4 === 10000;\n1e5 === 100000;\n\n```\n\n8\\. Object Property Shorthand\n-----------------------------\n\nDefining object literals in JavaScript makes life much easier. ES6 provides an even easier way of assigning properties to objects. If the property name is the same as the key name, you can take advantage of the shorthand notation.\n\nLonghand:\n\n```jsx\nconst obj = { x:x, y:y };\n\n```\n\nShorthand:\n\n```jsx\nconst obj = { x, y };\n\n```\n\n9\\. Arrow Functions Shorthand\n-----------------------------\n\nClassical functions are easy to read and write in their plain form, but they do tend to become a bit verbose and confusing once you start nesting them in other function calls.\n\nLonghand:\n\n```jsx\nfunction sayHello(name) {\n  console.log('Hello', name);\n}\n\nsetTimeout(function() {\n  console.log('Loaded')\n}, 2000);\n\nlist.forEach(function(item) {\n  console.log(item);\n});\n\n```\n\nShorthand:\n\n```jsx\nsayHello = name => console.log('Hello', name);\n\nsetTimeout(() => console.log('Loaded'), 2000);\n\nlist.forEach(item => console.log(item));\n\n```\n\nIt’s important to note that the value of `this` inside an arrow function is determined differently than for longhand functions, so the two examples are not strictly equivalent. See [this article on arrow function syntax](https://www.sitepoint.com/es6-arrow-functions-new-fat-concise-syntax-javascript/) for more details.\n\n10\\. Implicit Return Shorthand\n------------------------------\n\nReturn is a keyword we use often to return the final result of a function. An arrow functions with a single statement will implicitly return the result its evaluation (the function must omit the braces (`{}`) in order to omit the return keyword).\n\nTo return a multi-line statement (such as an object literal), it’s necessary to use `()` instead of `{}` to wrap your function body. This ensures the code is evaluated as a single statement.\n\nLonghand:\n\n```jsx\nfunction calcCircumference(diameter) {\n  return Math.PI * diameter\n}\n\n```\n\nShorthand:\n\n```jsx\ncalcCircumference = diameter => (\n  Math.PI * diameter;\n)\n\n```\n\n11\\. Default Parameter Values\n-----------------------------\n\nYou can use the if statement to define default values for function parameters. In ES6, you can define the default values in the function declaration itself.\n\nLonghand:\n\n```jsx\nfunction volume(l, w, h) {\n  if (w === undefined)\n    w = 3;\n  if (h === undefined)\n    h = 4;\n  return l * w * h;\n}\n\n```\n\nShorthand:\n\n```jsx\nvolume = (l, w = 3, h = 4 ) => (l * w * h);\n\nvolume(2) //output: 24\n\n```\n\n12\\. Template Literals\n----------------------\n\nAren’t you tired of using `' + '` to concatenate multiple variables into a string? Isn’t there a much easier way of doing this? If you are able to use ES6, then you are in luck. All you need to do is use is the backtick, and `${}` to enclose your variables.\n\nLonghand:\n\n```jsx\nconst welcome = 'You have logged in as ' + first + ' ' + last + '.'\n\nconst db = 'http://' + host + ':' + port + '/' + database;\n\n```\n\nShorthand:\n\n```jsx\nconst welcome = `You have logged in as ${first} ${last}`;\n\nconst db = `http://${host}:${port}/${database}`;\n\n```\n\n13\\. Destructuring Assignment Shorthand\n---------------------------------------\n\nIf you are working with any popular web framework, there are high chances you will be using arrays or data in the form of object literals to pass information between components and APIs. Once the data object reaches a component, you’ll need to unpack it.\n\nLonghand:\n\n```jsx\nconst observable = require('mobx/observable');\nconst action = require('mobx/action');\nconst runInAction = require('mobx/runInAction');\n\nconst store = this.props.store;\nconst form = this.props.form;\nconst loading = this.props.loading;\nconst errors = this.props.errors;\nconst entity = this.props.entity;\n\n```\n\nShorthand:\n\n```jsx\nimport { observable, action, runInAction } from 'mobx';\n\nconst { store, form, loading, errors, entity } = this.props;\n\n```\n\nYou can even assign your own variable names:\n\n```jsx\nconst { store, form, loading, errors, entity:contact } = this.props;\n\n```\n\n14\\. Multi-line String Shorthand\n--------------------------------\n\nIf you have ever found yourself in need of writing multi-line strings in code, this is how you would write it:\n\nLonghand:\n\n```jsx\nconst lorem = 'Lorem ipsum dolor sit amet, consectetur\\n\\t'\n    + 'adipisicing elit, sed do eiusmod tempor incididunt\\n\\t'\n    + 'ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t'\n    + 'veniam, quis nostrud exercitation ullamco laboris\\n\\t'\n    + 'nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t'\n    + 'irure dolor in reprehenderit in voluptate velit esse.\\n\\t'\n\n```\n\nBut there is an easier way. Just use backticks.\n\nShorthand:\n\n```jsx\nconst lorem = `Lorem ipsum dolor sit amet, consectetur\n    adipisicing elit, sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua. Ut enim ad minim\n    veniam, quis nostrud exercitation ullamco laboris\n    nisi ut aliquip ex ea commodo consequat. Duis aute\n    irure dolor in reprehenderit in voluptate velit esse.`\n\n```\n\n15\\. Spread Operator Shorthand\n------------------------------\n\nThe **spread operator**, introduced in ES6, has several use cases that make JavaScript code more efficient and fun to use. It can be used to replace certain array functions. The spread operator is simply a series of three dots.\n\nLonghand\n\n```jsx\n// joining arrays\nconst odd = [1, 3, 5];\nconst nums = [2 ,4 , 6].concat(odd);\n\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = arr.slice()\n\n```\n\nShorthand:\n\n```jsx\n// joining arrays\nconst odd = [1, 3, 5 ];\nconst nums = [2 ,4 , 6, ...odd];\nconsole.log(nums); // [ 2, 4, 6, 1, 3, 5 ]\n\n// cloning arrays\nconst arr = [1, 2, 3, 4];\nconst arr2 = [...arr];\n\n```\n\nUnlike the `concat()` function, you can use the spread operator to insert an array anywhere inside another array.\n\n```jsx\nconst odd = [1, 3, 5 ];\nconst nums = [2, ...odd, 4 , 6];\n\n```\n\nYou can also combine the spread operator with ES6 destructuring notation:\n\n```jsx\nconst { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };\nconsole.log(a) // 1\nconsole.log(b) // 2\nconsole.log(z) // { c: 3, d: 4 }\n\n```\n\n16\\. Mandatory Parameter Shorthand\n----------------------------------\n\nBy default, JavaScript will set function parameters to `undefined` if they are not passed a value. Some other languages will throw a warning or error. To enforce parameter assignment, you can use an `if` statement to throw an error if `undefined`, or you can take advantage of the ‘Mandatory parameter shorthand’.\n\nLonghand:\n\n```jsx\nfunction foo(bar) {\n  if(bar === undefined) {\n    throw new Error('Missing parameter!');\n  }\n  return bar;\n}\n\n```\n\nShorthand:\n\n```jsx\nmandatory = () => {\n  throw new Error('Missing parameter!');\n}\n\nfoo = (bar = mandatory()) => {\n  return bar;\n}\n\n```\n\n17\\. Array.find Shorthand\n-------------------------\n\nIf you have ever been tasked with writing a find function in plain JavaScript, you would probably have used a for loop. In ES6, a new array function named `find()` was introduced.\n\nLonghand:\n\n```jsx\nconst pets = [\n  { type: 'Dog', name: 'Max'},\n  { type: 'Cat', name: 'Karl'},\n  { type: 'Dog', name: 'Tommy'},\n]\n\nfunction findDog(name) {\n  for(let i = 0; i<pets.length; ++i) {\n    if(pets[i].type === 'Dog' && pets[i].name === name) {\n      return pets[i];\n    }\n  }\n}\n\n```\n\nShorthand:\n\n```jsx\npet = pets.find(pet => pet.type ==='Dog' && pet.name === 'Tommy');\nconsole.log(pet); // { type: 'Dog', name: 'Tommy' }\n\n```\n\n18\\. Object \\[key\\] Shorthand\n-----------------------------\n\nDid you know that `Foo.bar` can also be written as `Foo['bar']`? At first, there doesn’t seem to be a reason why you should write it like that. However, this notation gives you the building block for writing re-usable code.\n\nConsider this simplified example of a validation function:\n\n```jsx\nfunction validate(values) {\n  if(!values.first)\n    return false;\n  if(!values.last)\n    return false;\n  return true;\n}\n\nconsole.log(validate({first:'Bruce',last:'Wayne'})); // true\n\n```\n\nThis function does its job perfectly. However, consider a scenario where you have very many forms where you need to apply the validation but with different fields and rules. Wouldn’t it be nice to build a generic validation function that can be configured at runtime?\n\nShorthand:\n\n```jsx\n// object validation rules\nconst schema = {\n  first: {\n    required:true\n  },\n  last: {\n    required:true\n  }\n}\n\n// universal validation function\nconst validate = (schema, values) => {\n  for(field in schema) {\n    if(schema[field].required) {\n      if(!values[field]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\nconsole.log(validate(schema, {first:'Bruce'})); // false\nconsole.log(validate(schema, {first:'Bruce',last:'Wayne'})); // true\n\n```\n\nNow we have a validate function we can reuse in all forms without needing to write a custom validation function for each.\n\n19\\. Double Bitwise NOT Shorthand\n---------------------------------\n\nBitwise operators are one of those features you learn about in beginner JavaScript tutorials and you never get to implement them anywhere. Besides, who wants to work with ones and zeroes if you are not dealing with binary?\n\nThere is, however, a very practical use case for the Double Bitwise NOT operator. You can use it as a replacement for `Math.floor()`. The advantage of the Double Bitwise NOT operator is that it performs the same operation much faster. You can read more about Bitwise operators [here](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).\n\nLonghand:\n\n```jsx\nMath.floor(4.9) === 4  //true\n\n```\n\nShorthand:\n\n```jsx\n~~4.9 === 4  //true\n\n```\n\n20\\. Suggest One?\n-----------------\n\nI really do love these and would love to find more, please leave a comment!\n\n [![](https://secure.gravatar.com/avatar/9eada3b4136c22464245df9f55c3b0a1?s=96&d=mm&r=g)](https://www.sitepoint.com/author/mwanyoike/) \n\nMeet the author\n\n[Michael Wanyoike](https://www.sitepoint.com/author/mwanyoike/)[](https://twitter.com/myxsys)[](https://www.linkedin.com/in/mikewanyoike/)[](https://github.com/brandiqa)\n\nI write clean, readable and modular code. I love learning new technologies that bring efficiencies and increased productivity to my workflow.\n\n [![Sam Deering](https://d1nlfd9mjn1pae.cloudfront.net/wp-content/uploads/2014/05/1399880336profile-pic_400x400-96x96.jpg)](https://www.sitepoint.com/author/sdeering/) \n\nMeet the author\n\n[Sam Deering](https://www.sitepoint.com/author/sdeering/)[](https://twitter.com/samdeering)[](https://plus.google.com/104487173540464647216/)[](https://github.com/sdeering)\n\nSam Deering is a Front-end Web Developer who specialises in JavaScript & jQuery. Sam is driven and passionate about sharing his knowledge to educate others.","_id":"2DKvxBjoYH9lL4Vq"}
{"title":"test 123","sourceUrl":"","path":"JavaScript/","category":"JavaScript","tags":["JavaScript"," ES6"],"excerpt":"","date":"","coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"\"\ntitle: \"test 123\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","markdownCode":null,"_id":"HAn31eSLj4IY86mL"}
{"title":"Building forms using React — everything you need to know","sourceUrl":"https://www.codementor.io/blizzerand/building-forms-using-react-everything-you-need-to-know-iz3eyoq4y","path":"React/React/React/React/Building forms using React — everything you need to know","category":"React","tags":["React"," Form"],"excerpt":"test","date":{"$$date":1539094456041},"coverImage":"https://reactjs.org/docs/forms.html","type":"Post","frontmatter":"---\npath: \"JavaScript/\"\ndate: \"\"\ntitle: \"rererer\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/.md","markdownCode":"Forms are integral to any modern application. They serve as a basic medium for users to interact with your app. Developers rely on forms for everything: securely logging in the user, searching and filtering the product list, booking a product, and building a cart, etc. More complex applications built for enterprises are usually more form-intensive, with the input fields spanning over multiple tabs. On top of that, you have to consider the validation logic that needs to be deployed.\n\nIn this tutorial, we're going to look at how React handles forms. We'll cover not just the basics, but also form validation and best practices too — even experienced developers get certain details wrong.\n\nLet's get started.\n\n[](#creating-a-form-controlled-component-vs-uncontrolled-component)Creating a Form — Controlled Component vs. Uncontrolled Component\n------------------------------------------------------------------------------------------------------------------------------------\n\nReact offers a stateful, reactive approach to building forms. Unlike other DOM elements, HTML form elements work differently in React. The form data, for instance, is usually handled by the component rather than the DOM, and is usually implemented using controlled components. The image below perfectly describes how controlled components work in React.\n\n![react.png](https://process.filestackapi.com/cache=expiry:max/Qb7pi8kTzenybAUcijaB)\n\nThe form’s structure is similar to those of the usual HTML forms. However, each input element gets a component of its own, which we call dumb components. The container component is responsible for maintaining the state. The difference is, we're using a callback function to handle form events and then using the container’s state to store the form data. This gives your component better control over the form control elements and the form data.\n\nThe callback function is triggered on events, including change of form control values, or on form submission. The function then pushes the form values into the local state of the component and the data is then said to be controlled by the component. Because we are using the value attribute on the form element, the value displayed will be the value of `this.state.value`.\n\nThere is another technique, popularly known as uncontrolled components, for creating input forms. This is more like traditional HTML forms because the input form data is stored inside the DOM and not within the component. Elements like `<input>`and `<textarea>` maintain their own state, which they update when the input values change. You can query the DOM for the value of an input field using a ref.\n\nHere is an example from the [official docs](https://reactjs.org/docs/uncontrolled-components.html) that demonstrate how uncontrolled components work.\n\n```javascript\n class NameForm extends Component {\n  constructor(props) {\n    super(props);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n\n  handleSubmit(e) {\n    alert('The value is: ' + this.input.value);\n    e.preventDefault();\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input type=\"text\" ref={(input) => this.input = input} />\n        </label>\n        <input type=\"submit\" value=\"Submit\" />\n      </form>\n    );\n  }\n}\n\n\n```\n\nHere, the `<input>` component is responsible for storing its state. The ref attribute creates a reference to the DOM node accessible and you can pull this value when you need it — when you're about to submit the form in the example.\n\nReact recommends using controlled components over refs to implement forms. Refs offer a backdoor to the DOM, which might tempt you to use it to do things the jQuery way. Controlled components, on the other hand, are more straightforward — the form data is handled by a React component. However, if you want to integrate React with a non-React project, or create a quick and easy form for some reason, you can use a `ref`. The rest of this tutorial is going to focus on controlled components.\n\n[](#react-form-demo)React Form Demo\n-----------------------------------\n\nHere is the codesandobx demo for the form that we’ll be creating today.  \n@[React Form Demo](http://codesandbox.io/embed/x8omy0p9z)\n\nYou can also grab a copy of the code from [my GitHub repo](https://github.com/blizzerand/react-forms). Clone the repo, run `npm install`, and then run `npm start`.\n\n[](#structuring-a-form)Structuring a Form\n-----------------------------------------\n\nReact's composition model lets you organize your code into smaller reusable components. Each component exists as an independent functional unit and an hierarchy of components can be used to represent a specific feature. This structure works particularly well with forms. You can create custom components for `<input>`, `<textarea>`, `<select>`, etc. and reuse them to compose a `FormContainer` component.\n\nNote: although it could be tempting to use a form library instead, chances are high that you might come across obstacles when you need to add custom behavior and validation. Creating a reusable form component from scratch will help you bolster your understanding of React forms.\n\n```javascript\nimport React, { Component } from 'react';  \nimport './styles.css';  \nimport FormContainer from './containers/FormContainer';\n\nclass App extends Component {  \n  render() {\n    return (\n      <div className=\"container\">\n        <h3>React Form</h3>\n        <FormContainer />\n      </div>\n    );\n  }\n}\n\nexport default App; \n\n```\n\nFormContainer is a container component that renders all of the form elements and handles all of the business logic. We call it a container component because it takes care of updating the state of the form, handling form submission, and making API calls/dispatching Redux actions. The dumb components or presentational components are concerned with how things look and contain the actual DOM markup. These components receive data and callbacks exclusively as props. I've covered more about it on my [Stateful vs. Stateless components in React](https://code.tutsplus.com/tutorials/stateful-vs-stateless-functional-components-in-react--cms-29541) tutorial.\n\nLet's move on and create a container:\n\n```javascript\nimport React, {Component} from 'react';  \n\n/* Import Components */\nimport CheckBox from '../components/CheckBox';  \nimport Input from '../components/Input';  \nimport TextArea from '../components/TextArea';  \nimport Select from '../components/Select';\nimport Button from '../components/Button'\n\nclass FormContainer extends Component {  \n  constructor(props) {\n    super(props);\n\n    this.state = {\n      newUser: {\n        name: '',\n        email: '',\n        age: '',\n        gender: '',\n        expertise: '',\n        about: ''\n\n      },\n\n      genderOptions: ['Male', 'Female', 'Others'],\n      skillOptions: ['Programming', 'Development', 'Design', 'Testing']\n\n    }\n    this.handleFormSubmit = this.handleFormSubmit.bind(this);\n    this.handleClearForm = this.handleClearForm.bind(this);\n  }\n\n  /* This life cycle hook gets executed when the component mounts */\n\n  handleFormSubmit() {\n    // Form submission logic\n  }\n  handleClearForm() {\n    // Logic for resetting the form\n  }\n  render() {\n    return (\n      <form className=\"container\" onSubmit={this.handleFormSubmit}>\n\n        <Input /> {/* Name of the user */}\n        <Input /> {/* Input for Age */} \n        <Select /> {/* Gender Selection */}\n        <CheckBox /> {/* List of Skills (eg. Programmer, developer) */}\n        <TextArea /> {/* About you */}\n        <Button /> { /*Submit */ }\n        <Button /> {/* Clear the form */}\n      </form>\n    );\n  }\n}\n\nexport default FormContainer;\n}\n\n```\n\nFirst, we've imported the dumb components from the components directory. The components include `<Input>`, `<Select>`, `<CheckBox>`, `<TextArea>`, and `<Button>`.\n\nThen, we have initiated the state for storing the user data and the UI data. Two methods — `handleFormSubmit()` and `handleClearForm()` — have been created to handle the form logic. The render method renders all of the input fields and buttons required for our sign up form.\n\n[](#composing-the-dumb-components)Composing the Dumb Components\n---------------------------------------------------------------\n\nWe've laid out the structure of the form. Next, we need to compose the child components. Let's go through the components one by one.\n\n[](#input)<Input />\n-------------------\n\nThe `<Input />` component displays a one-line input field. The input type could be either text or number. Let's have a look at the props that we need to create an `<Input />` component.\n\n*   `type` — The `type` prop determines whether the input field rendered is of type, text, or number. For instance, if the value of `type` is equal to number, then `<input type=\"number\" />` will be rendered. Otherwise, `<input type=\"text\" />` gets rendered.\n*   `title` — The value of the title prop will be displayed as a label of that particular field.\n*   `name` — This is the name attribute for the input.\n*   `value` — The value (either text or number) that should be displayed inside the input field. You can use this prop to give default value.\n*   `placeholder` — An optional string that you can pass so that the input field displays a placeholder text.\n*   `handleChange` — A control function that gets triggered when the input control element's value changes. The function then updates the state of the parent component and passes the new value through the value prop.\n\nHere's the code for the `<Input/>` component. Note that we're using stateless functional components here.\n\n```javascript\nconst Input = (props) => {\n    return (  \n  <div className=\"form-group\">\n    <label htmlFor={props.name} className=\"form-label\">{props.title}</label>\n    <input\n      className=\"form-input\"\n      id={props.name}\n      name={props.name}\n      type={props.type}\n      value={props.value}\n      onChange={props.handleChange}\n      placeholder={props.placeholder} \n    />\n  </div>\n)\n}\n\nexport default Input;\n\n```\n\nYou can further expand the list of possible attributes and add them as props. Here is what the component's declaration looks like:\n\n```javascript\n<Input type={'text'}\n               title= {'Full Name'} \n               name= {'name'}\n               value={this.state.newUser.name} \n               placeholder = {'Enter your name'}\n               handleChange = {this.handleFullName}\n               /> {/* Name of the user */}\n               \n\n```\n\nThe `handleChange` callback takes care of updating the state and the updated value propagates through `props.value`. I am going to name the callback function as `handleFullName`.\n\n```javascript\n/* FormContainer.jsx */\n\n//...\n  handleFullName(e) {\n   let value = e.target.value;\n   this.setState( prevState => ({ newUser : \n        {...prevState.newUser, name: value\n        }\n      }))\n  }\n//...\n\n```\n\nThe `setState` accepts either an object or an updater function with the following signature.\n\n```\n(prevState, props) => stateChange\n\n```\n\nThe `prevState` object holds the up-to-date value of the previous state. We are going to merge the updated values with the previous state.\n\n_Note_: in JavaScript, class methods are not bound by default. You will need to bind it manually. What does that mean? You will need to add a binding into the constructor for each class method and the binding will look like this:\n\n```\nthis.handleFullName = this.handleFullName.bind(this)\n\n```\n\nAlternatively, you can use [class fields](https://github.com/tc39/proposal-class-fields) to do binding outside the constructor. The feature is still in experimental phase, so you will need to install the babel plugin [transform-class-properties to support it](https://babeljs.io/docs/plugins/transform-class-properties/).\n\nThe next input field is going to be for age. The logic of the `handleAge` will be similar to that of the `handleFullName` method.\n\n```\n/* FormContainer.jsx */\n\nhandleAge(e) {\n       let value = e.target.value;\n   this.setState( prevState => ({ newUser : \n        {...prevState.newUser, age: value\n        }\n      }), () => console.log(this.state.newUser))\n  }\n\n```\n\nThis method updates the state of this.state.newUser.age. Although this approach is okay, you can refactor the code and create a generic handler method that works for all `<Input />` components.\n\n```\n/* FormContainer.jsx */\n\nhandleInput(e) {\n     let value = e.target.value;\n     let name = e.target.name;\n     this.setState( prevState => {\n        return { \n           newUser : {\n                    ...prevState.newUser, [name]: value\n                   }\n        }\n     }, () => console.log(this.state.newUser)\n     )\n }\n\n```\n\n`handleInput()` will replace both `handleFullName()` and `handleAge()`. The only change we've made is to extract the value of name from form variable and then use that data to set the state. So, the value of the name prop should be same as the key of the property in the state.\n\nNext up, `<Select />`.\n\n[](#select)<Select />\n---------------------\n\nThe `<Select />` component displays a list of drop-down items. Usually, there will be a placeholder text or a default value for the drop-down. Here are the props for the `<Select />`:\n\n*   `title` — The value of the title prop be displayed as label of the `<select>` element.\n*   `name` — The name attribute for the `<select>` element.\n*   `options` — An array of available options. For instance, we are using the `<select />` to display a drop-down list of gender options.\n*   `value` — The value prop can be used to set the default value of the field.\n*   `placeholder` — A short string that populates the first `<option>` tag.\n*   `handleChange` — A control function that gets triggered when the input control element's value changes. The function then updates the state of the parent component and passes the new value through the value prop.\n\nLet's have a look at the actual code for the `<Select />` component.\n\n```javascript\n/*Select.jsx*/\n\nconst Select = (props) => {\n    return(\n        <div className=\"form-group\">\n            <label htmlFor={props.name}> {props.title} </label>\n            <select\n              name={props.name}\n              value={props.value}\n              onChange={props.handleChange}\n              >\n              <option value=\"\" disabled>{props.placeholder}</option>\n              {props.options.map(option => {\n                return (\n                  <option\n                    key={option}\n                    value={option}\n                    label={option}>{option}\n                  </option>\n                );\n              })}\n            </select>\n      </div>)\n}\n\nexport default Select;\n\n```\n\nThe first option tag is populated with the placeholder string. The rest of the options are mapped from the array that we passed on as props. While using the map method to iterate through DOM elements, remember to add a `key` attribute that's unique. This helps React keep track of DOM updates. If you leave out the `key` attribute, you will see a warning in your browser and might encounter performance issues down the road.\n\nNow, let's have a look at the callback function. The logic for method is similar to that of the generic handleInput that we created earlier. We can actually plug in that handler method as a prop and everything should work as expected.\n\n```javascript\n<Select title={'Gender'}\n       name={'gender'}\n       options = {this.state.genderOptions} \n       value = {this.state.newUser.gender}\n       placeholder = {'Select Gender'}\n       handleChange = {this.handleInput}\n/> {/* Age Selection */}\n\n```\n\n[](#checkbox)<CheckBox/>\n------------------------\n\nCheckboxes might appear a bit more complicated because arrays are involved. But both `<CheckBox>` and `<Select>` are similar in terms of props. The major difference lies in how the state is updated. Let's have a look at the props first.\n\n*   `title` — Already covered.\n*   `name` — Already covered.\n*   `options` — An array of available options. The array is usually composed of strings that end up being the label and the value of each checkbox.\n*   `selectedOptions` — An array of selected values. If the user had selected certain choices beforehand, the selectedOptions array would be populated with those values. This is synonymous to the <Select /> component's value prop.\n*   `handleChange` — Already covered.\n\nHere's the CheckBox component.\n\n```javascript\n/* CheckBox.jsx */\n\nconst CheckBox = (props) => {\n\n    return( <div>\n    <label for={props.name} className=\"form-label\">{props.title}</label>\n    <div className=\"checkbox-group\">\n      {props.options.map(option => {\n        return (\n          <label key={option}>\n            <input\n              className=\"form-checkbox\"\n              id = {props.name}\n              name={props.name}\n              onChange={props.handleChange}\n              value={option}\n              checked={ props.selectedOptions.indexOf(option) > -1 }\n              type=\"checkbox\" /> {option}\n          </label>\n        );\n      })}\n    </div>\n  </div>\n);\n\n}\n\n```\n\nThe line `checked={ props.selectedOptions.indexOf(option) > -1 }` might be confusing if you've never used JavaScript's `indexOf` method before. `indexOf` checks whether a particular item exists within an array and returns its index. Assuming that option holds a string, it checks whether the string exists within the `selectedOptions` and if the item doesn't exist in the array, it will return -1. This is the easiest way to populate values to a checkbox group in a form.\n\nSince we need to push an array into the state, which is more complicated than the usual `handleInput()`, let's create a new method for handling checkboxes.\n\n```javascript\nhandleSkillsCheckBox(e) {\n\n    const newSelection = e.target.value;\n    let newSelectionArray;\n\n    if(this.state.newUser.skills.indexOf(newSelection) > -1) {\n      newSelectionArray = this.state.newUser.skills.filter(s => s !== newSelection)\n    } else {\n      newSelectionArray = [...this.state.newUser.skills, newSelection];\n    }\n\n      this.setState( prevState => ({ newUser:\n        {...prevState.newUser, skills: newSelectionArray }\n      })\n      )\n}\n\n```\n\nThe user can interact with the checkbox in two ways — check an item, or uncheck an existing item. This user interaction corresponds to two actions — adding an item into the array, or removing an existing item from the array.\n\nThe `newSelection` variable has the value of the newly selected (or deselected) item. We compare it with the existing selection of items stored at `this.state.newUser.skills`. We're again going to rely on `indexOf` to check whether the string stored in `newSelection` is already of the array.  \nIf it's part of the array, the condition falls true and the new selection item is filtered out and stored in newSelection. Otherwise, the newSelection item is concatenated into the array using spread operator.\n\nFinally, the state is updated using `this.setState`.\n\n[](#textarea)<TextArea />\n-------------------------\n\nI am going to leave this as an exercise for the reader. This is fairly similar to the `<Input />` component that we created earlier. The `<textarea />` element should accept additional props for rows and columns. The code for the `TextArea` component is available in the sandbox demo for reference.\n\n[](#button)<Button />\n---------------------\n\nButtons are easiest of the lot. You can keep the `<Button />` component fairly simple and easy. Here is are the list of props that a button requires:\n\n*   `title` — Text for the button.\n*   `action` — Callback function\n*   `style` — Style objects can be passed as props.\n\nHere's the `<Button/>` in action:\n\n```javascript\n/*Button.jsx */\nconst Button = (props) => {\n    console.log(props.style);\n    return(\n        <button \n            style= {props.style} \n            onClick= {props.action}>    \n            {props.title} \n        </button>)\n}\n\nexport default Button;\n\n```\n\n[](#form-actions-handleclearform-and-handleformsubmit)Form Actions — `handleClearForm` and `handleFormSubmit`\n-------------------------------------------------------------------------------------------------------------\n\nWe've nearly reached the end of the tunnel. The last step is to compose the form actions. Since the FormContainer component maintains the state, the form action methods will go there.\n\nThe `handleClearForm` method will clear the state and set it back to its initial values.\n\n```javascript\nhandleClearForm(e) {\n\n      e.preventDefault();\n      this.setState({ \n        newUser: {\n          name: '',\n          age: '',\n          gender: '',\n          skills: [],\n          about: ''\n        },\n      })\n  }\n\n```\n\nThe line `e.preventDefault()` prevents the page from being refreshed on form submission, which is the default form behavior.\n\nThe `handleFormSubmit()` method takes care of making AJAX requests to the server. The data that needs to be sent is available at this.state.newUser. There are many libraries that you can use to make AJAX calls. I am going to use fetch here.\n\n```javascript\nhandleFormSubmit(e) {\n    e.preventDefault();\n    let userData = this.state.newUser;\n\n    fetch('http://example.com',{\n        method: \"POST\",\n        body: JSON.stringify(userData),\n        headers: {\n          'Accept': 'application/json',\n          'Content-Type': 'application/json'\n        },\n      }).then(response => {\n        response.json().then(data =>{\n          console.log(\"Successful\" + data);\n        })\n    })\n  }   \n\n```\n\nThat's it!\n\n[](#summary)Summary\n-------------------\n\nIn this article, we've covered everything that you need to know about building forms in React. React has component-based architecture and the components are meant to be reusable. We've gone ahead and created components for the input elements, such as: `<input/>`, `<select />`, `<textArea/>`, etc. You can further customize the components according to your requirements by passing more props.\n\nI hope you've had a good read. What are your thoughts about building forms using React? If you have anything to share, let us know in the comments.","_id":"RnFGXODGFlwDUYjI"}
{"title":"rererer ssasa","sourceUrl":"","path":"JavaScript/JavaScript/","category":"JavaScript","tags":["JavaScript"," ES6"],"excerpt":"","date":"","coverImage":"","type":"Post","frontmatter":"---\npath: \"JavaScript/JavaScript/\"\ndate: \"\"\ntitle: \"rererer ssasa\"\ntags: [\"JavaScript\",\"ES6\"]\ncategory: \"JavaScript\"\ncategoryColor: \"#F3C610\"\nexcerpt: \"\"\ncoverImage: \"\"\nsourceUrl: \"\"\ntype: \"Post\"\n---\n    ","filePath":"pages/JavaScript/JavaScript/.md","markdownCode":"\\--- path: \"JavaScript/\" date: \"\" title: \"rererer\" tags: \\[\"JavaScript\",\"ES6\"\\] category: \"JavaScript\" categoryColor: \"#F3C610\" excerpt: \"\" coverImage: \"\" sourceUrl: \"\" type: \"Post\" ---","_id":"lfc0XqCms5pgYRBg"}
{"$$indexCreated":{"fieldName":"name","unique":false,"sparse":false}}
